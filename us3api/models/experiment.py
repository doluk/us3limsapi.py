# coding: utf-8

"""
    UltraScan 3 LIMS Database Instance API

    A more machine-accessible version of the UltraScan 3 LIMS functionality. The authentication is done using the user's US3 LIMS credentials and sending them with every request as header `Us-Email` and `Us-Password`. Alternatively Basic Auth can be used.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from us3api.models.experiment_type import ExperimentType
from us3api.models.hpc_analysis_request import HPCAnalysisRequest
from us3api.models.project import Project
from us3api.models.raw_data import RawData
from us3api.models.run_type import RunType
from typing import Optional, Set
from typing_extensions import Self

class Experiment(BaseModel):
    """
    An experiment
    """ # noqa: E501
    experiment_id: StrictInt = Field(alias="experimentID")
    last_updated: datetime = Field(alias="lastUpdated")
    run_id: StrictStr = Field(alias="runID")
    project_id: StrictInt = Field(alias="projectID")
    label: StrictStr
    instrument_id: Optional[StrictInt] = Field(default=None, alias="instrumentID")
    operator_id: Optional[StrictInt] = Field(default=None, alias="operatorID")
    rotor_id: Optional[StrictInt] = Field(default=None, alias="rotorID")
    rotor_calibration_id: Optional[StrictInt] = Field(default=None, alias="rotorCalibrationID")
    experiment_guid: Optional[StrictStr] = Field(default=None, alias="experimentGUID")
    experiment_type: Optional[ExperimentType] = Field(default=ExperimentType.VELOCITY, alias="experimentType")
    run_type: Optional[RunType] = Field(default=None, alias="runType")
    protocol_id: Optional[StrictInt] = Field(default=None, alias="protocolID")
    run_temp: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="runTemp")
    date_begin: Optional[datetime] = Field(default=None, alias="dateBegin")
    projects: Optional[List[Project]] = None
    rawdata: Optional[List[RawData]] = None
    hp_crequests: Optional[List[HPCAnalysisRequest]] = Field(default=None, alias="HPCrequests")
    __properties: ClassVar[List[str]] = ["experimentID", "lastUpdated", "runID", "projectID", "label", "instrumentID", "operatorID", "rotorID", "rotorCalibrationID", "experimentGUID", "experimentType", "runType", "protocolID", "runTemp", "dateBegin", "projects", "rawdata", "HPCrequests"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Experiment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in projects (list)
        _items = []
        if self.projects:
            for _item in self.projects:
                if _item:
                    _items.append(_item.to_dict())
            _dict['projects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rawdata (list)
        _items = []
        if self.rawdata:
            for _item in self.rawdata:
                if _item:
                    _items.append(_item.to_dict())
            _dict['rawdata'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hp_crequests (list)
        _items = []
        if self.hp_crequests:
            for _item in self.hp_crequests:
                if _item:
                    _items.append(_item.to_dict())
            _dict['HPCrequests'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Experiment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "experimentID": obj.get("experimentID"),
            "lastUpdated": obj.get("lastUpdated"),
            "runID": obj.get("runID"),
            "projectID": obj.get("projectID"),
            "label": obj.get("label"),
            "instrumentID": obj.get("instrumentID"),
            "operatorID": obj.get("operatorID"),
            "rotorID": obj.get("rotorID"),
            "rotorCalibrationID": obj.get("rotorCalibrationID"),
            "experimentGUID": obj.get("experimentGUID"),
            "experimentType": obj.get("experimentType") if obj.get("experimentType") is not None else ExperimentType.VELOCITY,
            "runType": obj.get("runType"),
            "protocolID": obj.get("protocolID"),
            "runTemp": obj.get("runTemp"),
            "dateBegin": obj.get("dateBegin"),
            "projects": [Project.from_dict(_item) for _item in obj["projects"]] if obj.get("projects") is not None else None,
            "rawdata": [RawData.from_dict(_item) for _item in obj["rawdata"]] if obj.get("rawdata") is not None else None,
            "HPCrequests": [HPCAnalysisRequest.from_dict(_item) for _item in obj["HPCrequests"]] if obj.get("HPCrequests") is not None else None
        })
        return _obj


